/*
写在前面
本C++笔记参照 拓跋阿秀 公众号的《逆袭进大厂》系列
主要是C++的关键知识点和面试的考点
本笔记仅供个人学习，如有侵权，请联系删除
*/

/*1.在main函数执行之前和之后执行了哪些操作
	之前：
	（1）设置栈指针
	（2）初始化static变量和全局变量，即.data段的内容
	（3）将未初始化的全局变量赋初值（每个变量类型的0值），即.bss段
	（4）全局对象的初始化，调用该类的构造函数
	（5）将argc和argv等参数传递给main函数
	
	之后：
	（1）全局对象的析构函数
	（2）用atexit注册的函数会在main函数之后执行
*/

/*
2. 结构体内存对齐问题
（1）结构体中成员按照声明的顺序存储（所以在初始化列表中是按照声明顺序来初始化）
（2）第一个成员变量的地址和整个结构体的地址相同
（3）对齐方式是按照结构体中size最大的成员对齐（即 有double成员，按8个字节对齐）

*/

/*
3. 指针与引用
（1）指针是一个变量，存储的是一个地址；引用是变量的别名，本质上是同一个东西
（2）指针可以有多级；引用只能有一级
（3）指针可以为nullptr，也可以不初始化；引用不为空且必须初始化.
（4）指针可以改变指向（其存储的地址值）；引用不能改变
（5）sizeof(ptr)是指针变量的大小（4/8）；sizeof(ref)是所引用变量的大小
（6）参数传递时，指针需要拷贝，引用不需要拷贝；在函数中改变指针指向不影响实参，但引用可以影响实参
（7）指针需要存储空间，引用不占用存储空间
*/

/*
4. 栈和堆
补充点：内存五区
	1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其  操作方式类似于数据结构中的栈。  
	2、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束后可能由OS回收。
	3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  
	4、文字常量区：常量字符串就是放在这里的。程序结束后由系统释放  
	5、程序代码区：存放函数体的二进制代码。
栈和堆的区别：
（1）申请方式不同：栈是由系统自动分配，堆是自己申请和释放的
（2）申请大小限制不同：栈是向栈底扩展，栈顶和栈底都是预先设置好的，通过ulimit -a 查看，ulimit -u 修改；堆向高地址扩展，是不连续的内存空间，大小可以灵活调整
（3）申请效率不同：栈由系统分配，速度快，没有碎片；堆由程序员分配，速度慢，有碎片
*/

/*
5.指针数组、数组指针、函数声明、函数指针的区分
int* p[10]  -> 指针数组 存放10个int*的数组
int(*p)[10] -> 数组指针 1个指向有10个元素数组的指针
int *p(int) -> 函数声明  p 是一个函数
int (*p)(int) -> 函数指针  p是一个指向函数的指针  函数原型是  int Func(int)

*/

/*
6. 基类的虚函数表放在内存的什么区，虚表指针vptr的初始化时间
虚表的特征：（1）全局共享，在编译时就构造完成
			（2）虚表类似一个数组（不是函数，也不是代码，所以不在代码段）
			（3）虚表元素的个数在编译期确定，所以不在堆中
所以虚表类似静态成员变量，在全局静态区
构造函数中会对虚表指针进行初始化，虚表位于对象内存布局的最前面
结论：虚表位于只读数据段（.rodata），即常量区；虚函数位于代码段（.text），即代码区
*/

/*

7. new/delete和malloc/free 的异同
相同点：
都可以用于内存的动态申请和释放
不同点：
前者时c++的操作符；后者是c/c++的标准库函数
前者不需要库文件；后者需要
new 封装了malloc  使用free不会出错，但是不会调用对象的析构函数
new 自动计算分配的框架大小；malloc需要手动计算
new 时类型安全的；malloc不是
new 是封装了malloc，要执行2步操作：使用标准库函数operator new（本质是malloc）分配内存，再调用对象的构造函数；malloc仅能分配指定大小的内存空间并返回一个void*的指针
delete 会先调用对象的析构函数，再对内存进行释放（标准库函数operator delete）

delete和delete[]区别：
delete只会调用一次析构函数。
delete[]会调用数组中每个元素的析构函数。
*/

/*
8. 宏定义和函数的区别
宏在编译的预处理阶段完成替换，替换后的文本参与编译，运行是不存在调用，运行更快；函数调用需要跳转到具体的函数
宏没有返回值；函数有返回值
宏定义参数没有类型，不进行类型检查，函数需要进行类型检查
宏定义最后不要在后边加分号

*/

/*
9. 宏定义和typedef 的区别
宏定义用于定义常量和书写复杂的内容，typedef主要用于定义类型别名
宏替换发生在预处理阶段，是文本替换；typedef是编译的一部分
宏不进行类型检查，typedef会进行数据类型检查
宏不是语句，不要加分号；typedef是语句，需要加分号

*/











