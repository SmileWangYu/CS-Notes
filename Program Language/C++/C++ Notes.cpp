/*
写在前面
本C++笔记参照 拓跋阿秀 公众号的《逆袭进大厂》系列
主要是C++的关键知识点和面试的考点
本笔记仅供个人学习，如有侵权，请联系删除
*/

/*1.在main函数执行之前和之后执行了哪些操作
	之前：
	（1）设置栈指针
	（2）初始化static变量和全局变量，即.data段的内容
	（3）将未初始化的全局变量赋初值（每个变量类型的0值），即.bss段
	（4）全局对象的初始化，调用该类的构造函数
	（5）将argc和argv等参数传递给main函数
	
	之后：
	（1）全局对象的析构函数
	（2）用atexit注册的函数会在main函数之后执行
*/

/*
2. 结构体内存对齐问题
（1）结构体中成员按照声明的顺序存储（所以在初始化列表中是按照声明顺序来初始化）
（2）第一个成员变量的地址和整个结构体的地址相同
（3）对齐方式是按照结构体中size最大的成员对齐（即 有double成员，按8个字节对齐）

*/

/*
3. 指针与引用
（1）指针是一个变量，存储的是一个地址；引用是变量的别名，本质上是同一个东西
（2）指针可以有多级；引用只能有一级
（3）指针可以为nullptr，也可以不初始化；引用不为空且必须初始化.
（4）指针可以改变指向（其存储的地址值）；引用不能改变
（5）sizeof(ptr)是指针变量的大小（4/8）；sizeof(ref)是所引用变量的大小
（6）参数传递时，指针需要拷贝，引用不需要拷贝；在函数中改变指针指向不影响实参，但引用可以影响实参
（7）指针需要存储空间，引用不占用存储空间
*/

/*
4. 栈和堆
补充点：内存五区
	1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其  操作方式类似于数据结构中的栈。  
	2、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束后可能由OS回收。
	3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  
	4、文字常量区：常量字符串就是放在这里的。程序结束后由系统释放  
	5、程序代码区：存放函数体的二进制代码。
栈和堆的区别：
（1）申请方式不同：栈是由系统自动分配，堆是自己申请和释放的
（2）申请大小限制不同：栈是向栈底扩展，栈顶和栈底都是预先设置好的，通过ulimit -a 查看，ulimit -u 修改；堆向高地址扩展，是不连续的内存空间，大小可以灵活调整
（3）申请效率不同：栈由系统分配，速度快，没有碎片；堆由程序员分配，速度慢，有碎片
*/

/*
5.指针数组、数组指针、函数声明、函数指针的区分
int* p[10]  -> 指针数组 存放10个int*的数组
int(*p)[10] -> 数组指针 1个指向有10个元素数组的指针
int *p(int) -> 函数声明  p 是一个函数
int (*p)(int) -> 函数指针  p是一个指向函数的指针  函数原型是  int Func(int)

*/

/*
6. 基类的虚函数表放在内存的什么区，虚表指针vptr的初始化时间
虚表的特征：（1）全局共享，在编译时就构造完成
			（2）虚表类似一个数组（不是函数，也不是代码，所以不在代码段）
			（3）虚表元素的个数在编译期确定，所以不在堆中
所以虚表类似静态成员变量，在全局静态区
构造函数中会对虚表指针进行初始化，虚表位于对象内存布局的最前面
结论：虚表位于只读数据段（.rodata），即常量区；虚函数位于代码段（.text），即代码区
*/

/*

7. new/delete和malloc/free 的异同
相同点：
都可以用于内存的动态申请和释放
不同点：
前者时c++的操作符；后者是c/c++的标准库函数
前者不需要库文件；后者需要
new 封装了malloc  使用free不会出错，但是不会调用对象的析构函数
new 自动计算分配的框架大小；malloc需要手动计算
new 时类型安全的；malloc不是
new 是封装了malloc，要执行2步操作：使用标准库函数operator new（本质是malloc）分配内存，再调用对象的构造函数；malloc仅能分配指定大小的内存空间并返回一个void*的指针
delete 会先调用对象的析构函数，再对内存进行释放（标准库函数operator delete）

delete和delete[]区别：
delete只会调用一次析构函数。
delete[]会调用数组中每个元素的析构函数。
*/

/*
8. 宏定义和函数的区别
宏在编译的预处理阶段完成替换，替换后的文本参与编译，运行是不存在调用，运行更快；函数调用需要跳转到具体的函数
宏没有返回值；函数有返回值
宏定义参数没有类型，不进行类型检查，函数需要进行类型检查
宏定义最后不要在后边加分号

*/

/*
9. 宏定义和typedef 的区别
宏定义用于定义常量和书写复杂的内容，typedef主要用于定义类型别名
宏替换发生在预处理阶段，是文本替换；typedef是编译的一部分
宏不进行类型检查，typedef会进行数据类型检查
宏不是语句，不要加分号；typedef是语句，需要加分号

*/

/*
10. 变量声明和定义的区别
变量声明仅仅是把变量声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为变量分配内存空间
相同的变量可以在多处声明（外部变量为extern），但只能在一处定义

*/

/*
11. 什么情况下必须使用初始化成员列表
（1）初始化一个const成员
（2）初始化一个引用成员
（3）调用基类的构造函数
（4）调用成员变量的构造函数
*/

/*
12. strlen 和sizeof 的区别
sizeof 是运算符，不是函数，结果实在编译时确定而非运行时；strlen是字符串处理的库函数
sizeof的参数可以是任何类型或者数据（有继承关系的不会退化）；strlen 的参数只能是char* 并且是以\0结尾的字符串
sizeof只能在编译时确定，所以不能用来动态分配存储空间的大小

*/

/*
13. 常量指针 和 指针常量 
const int* p -> 常量指针 （本质是一个指针，指针指向的是一个常量）
int* const p -> 指针常量 （本质是一个常量，指针不能被再次赋值，也就是指针不能改变指向）

*/

/*
14. 数组名和指针（指向数组首地址的指针）的区别
（1）二者都可以通过+-偏移值来访问数组中的元素
（2）数组名不是真正意义上是指针，可以理解为指针常量，不可以做自增自减操作
（3）当数组名作为实参传递给调用函数后，就失去了原有数组的特性，退化成一般指针，可以进行++/--操作，但是sizeof运算的结果是指针的大小而不是数组大小

ps：
int a[10];
int (*p)[10] = &a;
p 是指向长度为10的数组的指针，p++后移动的是10个int的位置
*/

/*
15. 野指针和悬空指针
都是指向无效内存区域的指针（不安全不可控）
野指针：没有被初始化的指针，为了防止错误一般都初始化为nullptr
悬空指针：指针指向的内存空间已经被释放了，delete操作后要将指针置为nullptr
*/

/*
16. 迭代器失效的情况
（1）序列式容器，以vector为例
序列式容器，在内存中是一块连续的内存，当删除一个元素后，内存中的数据就会发生移动，保证数据的紧凑，导致之前得到的迭代器不能访问正确的数据
for(auto it = v.begin(); it != v.end();){
	if(*it > 3){
		it = v.erase(it); // erase函数会返回一个正确的迭代器
	}else{
		it++;
	}
	
}

插入一个元素：
在尾部插入，当size < capacity 首部迭代器不失效，尾部迭代器失效
			当size == capacity 都失效，因为需要重新分配空间
在中间插入，当size < capacity 首部迭代器不失效但插入元素之后的所有迭代器都失效
			当size == capacity 所有迭代器都失效

（2）关联式容器
删除当前的迭代器，只有当前iterator失效，因为底层实现是红黑树
所以对于关联式容器，删除后只需要将迭代器++即可
erase方法发返回值是void

（3）链表式容器，以list为例
删除当前的迭代器，只有当前iterator失效，因为底层实现是链表
erase方法的返回值是下一个有效的迭代器

*/

/*
17. C 和 C++ 的区别
（1）C++中new 和delete是堆内存分配的运算符，取代了C中的malloc 和free
（2）标准c++的字符串类取代了c库函数中的字符数组处理函数
（3）c++中用iostream类库取代了c中stdio函数库
（4）c++使用try/catch/throw异常处理机制取代c中的setjmp()和longjmp()函数
（5）C++中可以函数重载，C中不可以
（6）C++中变量可以定义在程序的任何地方，c中变量必须定义在函数开头；C++可以重复定义变量
（7）C++除了值和指针还增加了引用
（8）C++增加了一些关键字 -- bool using dynamic_cast namespace

*/

/*
18. C++ 中struct 和class的异同
相同点：两者都有成员变量和成员方法，共有和私有部分
		任何class能够完成的工作，同意可以使用struct完成
不同点：成员访问修饰权限  struct默认是public class 默认是pivate
		继承			  class默认是private继承 struct 默认是public 继承
		class 可以做模板 struct不行

ps：c和c++中struct的区别:
	c语言中struct是UDT C++中struct是ADT
	c语言中使用方法 typedef struct{} A; struct A a;
	c语言中的struct更像一个变量集合体，封装数据却不隐藏数据，也没有成语函数
*/

/*
19. define 和const的区别
编译阶段
	define 是在编译的预处理阶段做文本替换，const是在编译运行时
安全性
	define 只做文本替换，不检查，容易出错
	const常量有数据类型，编译器可以进行类型安全检查
内存占用
	define只是将宏名进行替换，在内存中产生多分相同的备份，const在运行时只有一份备份，并且可以进行常量折叠（像宏替换一样把对常量的引用替换为常量对应的值），也可以将复杂的表达式计算出结果放入常量表
	宏定义的数据没有分配内存空间，只是文本替换；const定义的变量只是值不能改变，但要分配内存空间
	
*/

/*
20. C++ 中const和static的作用
static ：
（1）不考虑 类 的情况
	隐藏：不加static的全局变量和全局函数具有全局可见性，加了static修饰，只能在当前文件中使用
	默认初始化：全局静态变量和局部静态变量都在全局未初始化区，可以赋0值
	函数内的静态变量，始终存在，且只进行一次初始化，函数退出后仍然存在，但是不能使用
（2）考虑 类 的情况
	static 成员变量，只与类关联，不与对象关联；定义时分配空间，不能在类声明中初始化，必须在类定义体外部将那些初始化，初始化不需要标志为static，可以被非static成员变量任意访问。
	static 成员函数，不具有this指针，无法访问类对象的非static成员变量和非static函数，不能被声明为const、虚函数和volatile，可以被非const成员函数任意访问。

const 
	（1）不考虑 类 的情况
	const常量必须在定义时初始化，之后无法更改
	const形参可以接受const和非const类型的实参
	（2）考虑 类 的情况
	const成员变量，不能在类外部初始化，只能通过构造函数的初始化列表进行初始化，并且必须有构造函数；不能在类声明时初始化（因为不同的类堆const数据成员的值可以不同）
	const成员函数
	const对象不可以调用非const的成员函数，非const的对象都可以调用；不可以改变非mutable数据的值（即：用mutable修饰的变量可以在const成员函数中修改）
	
*/

/*
21. C++ 的顶层const 和 底层const
顶层const：const修饰的变量本身是一个常量，*号右边
底层const：const修饰的变量指向的对象是一个常量，*号左边

对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const
使用const_cast只能改变运算对象的底层const

*/

/*
22. 类对象的存储空间
非静态成员数据类型大小之和
编译器额外添加的成员变量（例如指向虚表的指针）
为了边缘对齐优化加入的padding

*/

/*
23. final 和override 关键字
override 
在继承关系中有虚函数，通过指定override关键字来声明函数时重写的虚函数，以防止不小心函数名写错（写错了，编译会报错）

final
final关键字可以防止类被继承，防止某个虚函数被重写
class A {
public:
	void foo() final;
};
class B final : A{
public:
	void foo() override; // Error
};

class C : B{};  // Error
*/

/*
24. extern "C" 的用法
作用：在C++代码中正确的使用C语言的代码，extern "C"告诉编译器这部分代码是C语言编写的，编译时要按照C语言的形式编译
extern "C"只能在头文件和cpp文件中
用法：
（1）C++调用C函数
// xx.h
extern int add()
// xx.c
int add(){}
// xx.cpp
extern "C" {
	#include "xx.h"
}
（2）C调用C++函数
// xx.h
extern "C" {
	int add();
}
// xx.cpp
int add(){}
// xx.c 
extern int add();

*/

/*
25. 模板函数和模板类的特例化

*/













